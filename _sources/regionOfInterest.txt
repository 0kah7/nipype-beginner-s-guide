=========================================
How To Extract Regions Of Interest (ROIs)
=========================================

In this part we will learn how to extract statistical data from a specified region or also called a **region of interest (ROI)**.

Anatomical and Functional ROIs
==============================

Anatomical and functional ROIs differ mostly by the way how they define the region of interest.

Anatomical ROI
~~~~~~~~~~~~~~

The region of an anatomical ROI is as the name implies defined by the anatomical structure of the brain (e.g. Thalamus, Putamen, Ventricle, Amygdala etc.). Such definitions of anatomical regions and there segmentations is stored in so called **atlas**. A well known atlas which is used by **Nipype** by default is the `FreeSurfer Color Table <http://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/AnatomicalROI/FreeSurferColorLUT>`_.

This color table subdivides the brain in over 1000 different anatomical regions. The **FreeSurfer Color Table** enables to differentiate between gray and white matter areas. The table is divided into different sections. For the extraction of anatomical ROIs we are interested in the **original Segmentation** and in the **2009 Segmentation**.

.. note::

   Note that this separation between original and 2009 version of segmentation is defined by me and how I would subdivide the color table and by no means represent the structure that FreeSurfer intended.

The following list shows a part of the **FreeSurfer Color Table**. Import for us is the segmentation **id** and segmentation **name**, shown in the first two columns.

.. code-block:: none

   #No. Label Name:                            R   G   B   A
   [...]
   9   Left-Thalamus                           0   118 14  0
   10  Left-Thalamus-Proper                    0   118 14  0
   11  Left-Caudate                            122 186 220 0
   12  Left-Putamen                            236 13  176 0
   13  Left-Pallidum                           12  48  255 0
   14  3rd-Ventricle                           204 182 142 0
   15  4th-Ventricle                           42  204 164 0
   16  Brain-Stem                              119 159 176 0
   17  Left-Hippocampus                        220 216 20  0
   18  Left-Amygdala                           103 255 255 0
   19  Left-Insula                             80  196 98  0
   20  Left-Operculum                          60  58  210 0
   [...]
   48  Right-Thalamus                          0   118 14  0
   49  Right-Thalamus-Proper                   0   118 14  0
   50  Right-Caudate                           122 186 220 0
   51  Right-Putamen                           236 13  176 0
   52  Right-Pallidum                          13  48  255 0
   53  Right-Hippocampus                       220 216 20  0
   54  Right-Amygdala                          103 255 255 0
   55  Right-Insula                            80  196 98  0
   56  Right-Operculum                         60  58  210 0
   [...]


The ids from *1 to 999* can be found in the original as well as in the 2009 version of segmentation. The ids *1000 to 8014* can only be found in the **original version** and the ids *11100 to 14175* can only be found in the **2009 version** of segmentation.


**Visualization of original Segmentation**: The following picture shows you the labels of the original segmentation. The annotation of which color belongs to which region is stored in ``~SOMEPATH/experiment/freesurfer_data/fsaverage/label/lh.aparc.annot`` (if you're interested in the left hemisphere)

.. image:: segorig.png
   :width: 512 px


**Visualization of 2009 Segmentation**: The following picture shows you the labels of the 2009 segmentation. The annotation of which color belongs to which region is stored in ``~SOMEPATH/experiment/freesurfer_data/fsaverage/label/rh.aparc.a2009s.annot`` (if you're interested in the right hemisphere)

.. image:: seg2009.png
   :width: 512 px

.. hint::

   If you want to explore those regions by ourself I recommend to open a **FreeSurfer** capable viewing tool and overlay the annotation file from the ``fsaverage/label`` folder. 


Functional ROI
~~~~~~~~~~~~~~

The most important difference to the extraction of an anatomical ROI is that the functional region of interest isn't predefined by some atlas but is solely defined by a point in "brain"-space that you are interested in. You're region of interest is most likely a point of strong or interesting activation in your functional data, hence its name. The following is a visualization of a thresholded contrast from our previous second level analysis. The contrast has a cluster threshold of 0.001 and a fdr-p-voxel threshold of 0.05.

.. image:: fROI1.png
   :width: 810 px

The specification of our region of interest can now be done in different ways. Some may want to look at a cubic region with the point of interest as its center. Others want to extract a spherical region around a point of interest. It would also be possible to extract exact exactly all the voxel you can see in the picture above.

In this example we will extract the data around a spherical ROI with the point [179, 129, 107] in MNI-space as its center and a radius of 20 voxel from the thresholded contrast above. The procedure to do this is quite simple:

1. We define a point of interest and create a sphere around it. This step has to be divided into the following substeps to be achieved:

   a. Create a cube around your point of interest so that the region you want to be cover is covered
   b. Transform the cube into a sphere by smoothing it

2. We create a ROI which is the intersection of this spherical ROI and the thresholded activation from the second level analysis
3. We extract the data from this intersection.

Let's take a closer look at those steps.

**Step 1a: Create a cube around your point of interest**

To create this cube around the point of interest some not so obvious steps have to be done. **First**, take a contrast with the dimensions of your normbrain, multiply all voxel by 0 and add the value 1 to each. **Second**, define a cubic area around your point of interest by specifying the lowest corners of the cube and the length of its sides. In this example this is 20. This will left you with a cubic region where all voxel inside the cube have value 1 and all voxel outside the cube have value 0.

.. image:: fROI2.png
   :width: 810 px


**Step 1b: Smooth the cube to a sphere**

To do this, take the cube and smooth it to a sphere with radius 20. If you're using ``fsl.ImageMaths()`` you have to first threshold the sphere with 0.5 and binarize it afterwards. Now you have sphere with the same diameter as the side of the cube was.

.. image:: fROI3.png
   :width: 810 px

   
**Step 2: Create the intersection between the thresholded contrast and the sphere**

To create the ROI that is the intersection of the active voxels from the thresholded contrast and the sphere we have have to multiply the sphere with the thresholded contrast.

.. image:: fROI4.png
   :width: 810 px


**Step 3: Extract the data from this intersection**

By feeding this self defined ROI into ``fs.SegStats()`` we can extract the values of this region.


Anatomical ROI Pipeline
=======================

Let's now begin with the creation of an **anatomical ROI pipeline**.


Import modules
~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   import os                                    # system functions
   import nipype.interfaces.freesurfer as fs    # freesurfer
   import nipype.interfaces.io as nio           # i/o routines
   import nipype.interfaces.utility as util     # utility
   import nipype.pipeline.engine as pe          # pypeline engine


Define experiment specific parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   #to better access the parent folder of the experiment
   experiment_dir = '~SOMEPATH/experiment'

   # Tell freesurfer what subjects directory to use
   subjects_dir = experiment_dir + '/freesurfer_data'
   fs.FSCommand.set_default_subjects_dir(subjects_dir)

   #dirnames for anatomical ROI pipeline
   aROIOutput = 'aROI_output'      #name of aROI datasink
   l1contrastDir = 'level1_output' #name of first level datasink
   
   #list of subjectnames
   subjects = ['subject1', 'subject2', 'subject3']
   
   #list of contrastnumbers the pipeline should consider
   contrasts = ['01','02','03','04','05']

   #name of the first session from the first level pipeline
   nameOfFirstSession = 'func1'
   
.. note::

   The **name of the first session** is necessary, because the bbregister file from the first level pipeline contains the name of the first session in its name. E.g. if the first condition is ``func1``, than the name of the bbregister file for the second subject is ``meanafunc1_bbreg_subject2.dat``.

Define aROI specific parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As mentioned above we are using the `FreeSurfer Color Table <http://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/AnatomicalROI/FreeSurferColorLUT>`_ to define the anatomical regions. Let's assume that we want to extract the following regions:

* id ``11`` ; ``Left-Caudate`` ; from **both** segmentations
* id ``50`` ; ``Right-Caudate`` ; from **both** segmentations
* id ``12`` ; ``Left-Putamen`` ; from **both** segmentations
* id ``51`` ; ``Right-Putamen`` ; from **both** segmentations
* id ``1007`` ; ``ctx-lh-fusiform`` ; from the **original** segmentation
* id ``2007`` ; ``ctx-rh-fusiform`` ; from the **original** segmentation
* id ``1022`` ; ``ctx-lh-postcentral`` ; from the **original** segmentation
* id ``2022`` ; ``ctx-rh-postcentral`` ; from the **original** segmentation
* id ``11134`` ; ``ctx_lh_G_temp_sup-Lateral`` ; from the **2009** segmentation
* id ``12134`` ; ``ctx_rh_G_temp_sup-Lateral`` ; from the **2009** segmentation

.. code-block:: py
   :linenos:

   #Specification of the regions from the original and 
   #the 2009 segmentation version of the FreeSurfer Color Table
   ROIregionsorig = ['11','50','12','51','1007','2007','1022','2022']
   ROIregions2009 = ['11134','12134']


.. note::

   There is no harm by defining a segmentation id in the wrong segmentation version, but if you specify an id between 1000 to 9999 in the ``ROIregions2009`` list, you just won't extract any other value than 0 from your data.
      

Define nodes
~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   #Node: IdentityInterface - to iterate over subjects and contrasts
   inputnode = pe.Node(interface=util.IdentityInterface(fields=['subject_id','contrast_id']),
                       name='inputnode')
   inputnode.iterables = [('subject_id', subjects),
                          ('contrast_id', contrasts)]

As always when we define the ``DataGrabber`` node, it is important to be aware of the structure and the files that we want to grab. In this case we want to grab the subject specific contrasts and bbregister file from the first level pipeline.

In our version the **second contrast** for the **third subject** can be found at: ``~SOMEPATH/experiment/results/level1_output/vol_contrast/_subject_id_subject3/
con0002.img`` and the **bbregister file** for the **first subject** can be found at: ``~SOMEPATH/experiment/results/level1_output/bbregister/_subject_id_subject1/
meanafunc1_bbreg_subject1.dat``. Knowing this, we can build our ``datagrabber`` node as follows:

.. code-block:: py
   :linenos:

   #Node: DataGrabber - to grab the input data
   datasource = pe.Node(interface=nio.DataGrabber(infields=['subject_id','contrast_id'],
                                                  outfields=['contrast','bb_id']),
                        name = 'datasource')
   datasource.inputs.base_directory = experiment_dir + '/results/' + l1contrastDir
   datasource.inputs.template = '%s/_subject_id_%s/%s%s%s'
   
   info = dict(contrast = [['vol_contrasts','subject_id','con_00','contrast_id','.img']],
               bb_id = [['bbregister','subject_id','meana'+nameOfFirstSession+'_bbreg_',
                         'subject_id','.dat']])   
   datasource.inputs.template_args = info
   

Let's now continue with the implementation of the other nodes that we need for our **anatomical ROI pipeline**.
   
.. code-block:: py
   :linenos:

   #Node: FreeSurferSource - to grab FreeSurfer files from the recon-all process
   fssource = pe.Node(interface=nio.FreeSurferSource(),name='fssource')
   fssource.inputs.subjects_dir = subjects_dir
   
   #Node: MRIConvert - to convert files from FreeSurfer format into nifti format
   MRIconversion = pe.Node(interface=fs.MRIConvert(),name='MRIconversion')
   MRIconversion.inputs.out_type = 'nii'
   
   #Node: ApplyVolTransform - to transform contrasts into anatomical space
   #                          creates 'con_*.anat.bb.mgh' files
   transformation = pe.Node(interface=fs.ApplyVolTransform(),name='transformation')
   transformation.inputs.fs_target = True
   transformation.inputs.interp = 'nearest'
   
   #Node: SegStatsorig - to extract specified regions of the original segmentation
   segmentationorig = pe.Node(interface=fs.SegStats(),name='segmentationorig')
   segmentationorig.inputs.segment_id = ROIregionsorig

   #Node: SegStats2009 - to extract specified regions of the 2009 segmentation
   segmentation2009 = pe.Node(interface=fs.SegStats(),name='segmentation2009')
   segmentation2009.inputs.segment_id = ROIregions2009

   #Node: Datasink - Creates a datasink node to store important outputs
   datasink = pe.Node(interface=nio.DataSink(), name="datasink")
   datasink.inputs.base_directory = experiment_dir + '/results'
   datasink.inputs.container = aROIOutput 


.. note::

   We implement two ``SegStats`` nodes because we have two lists of segmentation, the ``original`` and the ``2009`` one. It might be possible two feed those values into one node with using iterables, but I prefer this way.

   If you don't specify a value for ``segment_id`` the pipeline will extract all regions of your atlas. This is not bad but can take a long time.



Definition of anatomical ROI workflow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   #Initiation of the ROI extraction workflow
   aROIflow = pe.Workflow(name='aROIflow')
   aROIflow.base_dir = experiment_dir + '/results/workingdir_aROI'


Before we can start with the integration of the nodes into ``aROIflow`` we have to be aware about something. If we would try to simply connect ``fssource`` with ``segmentationorig`` like this...

.. code-block:: py

   ...(fssource, segmentationorig,[('aparc_aseg','segmentation_file')]),

... we would get the following error:

.. code-block:: py

   Node: segmentationorig
   input: segmentation_file
   TraitError: The 'segmentation_file' trait of a SegStatsInputSpec instance must be an
   existing file name, but a value of ['~SOMEPATH/experimentfreesurfer_data/
   subject1/mri/aparc+aseg.mgz', '~SOMEPATH/experiment/freesurfer_data/subject1/mri
   /aparc.a2009s+aseg.mgz'] <type 'list'> was specified.

This means that the output of the ``fssource`` node has the value: ``['~SOMEPATH/experiment/freesurfer_data/subject1/mri/aparc+aseg.mgz', '~SOMEPATH/experiment/freesurfer_data/subject1/mri/aparc.a2009s+aseg.mgz']``. That means we have to guide the output of this node so that ``segmentationorig`` receives the path to ``aparc+aseg.mgz`` and that ``segmentation2009`` receives the path to ``aparc.a2009s+aseg.mgz``.

This can be achieved with a simple function:

.. code-block:: py
   :linenos:

   def getSegVersion(in_file, version):
       if version == 0:
          return in_file[0]
       else:
          return in_file[1]

Now we are ready to build our **anatomical ROI pipeline**.

.. code-block:: py
   :linenos:

   #Connect up all components
   aROIflow.connect([(inputnode, datasource,[('subject_id','subject_id'),
                                             ('contrast_id','contrast_id'),
                                             ]),
                     (inputnode, fssource,[('subject_id','subject_id')]),
                     (fssource, segmentationorig,[(('aparc_aseg',getSegVersion,0),
                                                    'segmentation_file')]),
                     (fssource, segmentation2009,[(('aparc_aseg',getSegVersion,1),
                                                    'segmentation_file')]),
                     (datasource, MRIconversion,[('contrast','in_file')]),
                     (MRIconversion, transformation,[('out_file','source_file')]),
                     (datasource, transformation,[('bb_id','reg_file')]),
                     (transformation, segmentationorig,[('transformed_file',
                                                         'in_file')]),
                     (transformation, segmentation2009,[('transformed_file',
                                                         'in_file')]),
                     (segmentationorig, datasink,[('summary_file', 'segstatorig')]),
                     (segmentation2009, datasink,[('summary_file', 'segstat2009')]),
                     ])
   

Run pipeline and generate graph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   aROIflow.write_graph(graph2use='flat')
   aROIflow.run(plugin='MultiProc', plugin_args={'n_procs' : 2})


Visualization of the anatomical ROI pipeline
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This graph of the ``hierarchical`` version shows the ``aROIflow``:

.. image:: aROI_hierarchical.png
   :width: 810 px

This detailed graph of the ``flat`` version shows the ``aROIflow``:

.. image:: aROI_detailed.png
   :width: 810 px


Summarizing the output in a cvs-file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This part is optional and shows only one of many ways how you can summarize the output of ``aROIflow`` into a common cvs-file. In essence it does the following steps for each contrast:

* grab contrast and subject specific ``summary.stats`` file
* extract values from this file and store it into a list
* add the list of each subject into a bigger list
* store this big list into a csv-file

.. code-block:: py
   :linenos:
   
   #iterate over contrasts and create a cvs-file for each
   for contrast in contrasts:

       #creates a list with an empty entry for each segmentation id
       output = []
       for i in range(15000):
           output.append([i,None])
   
       #to keep track of added subjects
       subjectNumber = 1
   
       #iterate over subjects and entering values into output
       for subject in subjects:
      
           #specify path to aROI datasink for each variation of segmentation
           path2aROIOut = experiment_dir+'/results/'+aROIOutput
           path2Sumfile = '_contrast_id_'+contrast+'_subject_id_'+subject+'/summary.stats'
           statsFileorig = path2aROIOut+'/segstatorig/'+path2Sumfile
           statsFile2009 = path2aROIOut+'/segstat2009/'+path2Sumfile
      
           #extract the data from the output summary files
           dataFile = open(statsFileorig, 'r')
           dataorig = dataFile.readlines()
           dataFile.close()
           dataFile = open(statsFile2009, 'r')
           data2009 = dataFile.readlines()
           dataFile.close()
          
           #function to check where the data starts
           def findStartOfData(datafile):
               for line in range(100):
                   if datafile[line][0] != '#':
                      return line
          
           #get data and store it in tempresult
           tempresult = []
      
           for line in range(len(dataorig)):
               if line < findStartOfData(dataorig):
                   pass
               else:
                   temp = dataorig[line].strip('\n').split()
                   tempresult.append([int(temp[1]),temp[4],float(temp[5])])
   
           for line in range(len(data2009)):
               if line < findStartOfData(data2009):
                   pass
               else:
                   temp = data2009[line].strip('\n').split()
                   tempresult.append([int(temp[1]),temp[4],float(temp[5])])
      
           tempresult.sort()
      
           result = []
   
           for line in range(len(tempresult)):
               #pass if region has already been added
               if line > 0 and tempresult[line] == tempresult[line-1]:
                   pass
               else:
                   result.append(tempresult[line])
      
           for ROI in result:
               #if id wasn't extracted before, adds name of id to row
               if output[ROI[0]][1] == None:
                  output[ROI[0]][1] = ROI[1]
               #adds value of id into row
               output[ROI[0]].append(ROI[2])
      
           #if no value for an id was entered for a subject
           #   the value 0.0 gets added
           for ROI in output:
               if len(ROI) < subjectNumber+2:
                  ROI.append(0.0)
      
           subjectNumber += 1
      
       #adds labels to the first row of the output
       output.insert(0,['SegId','StructName'])
       output[0].extend(subjects)
   
       #adds segment if it was extracted
       output = [ROI for ROI in output if ROI[1] != None]
      
       #define name of the output csv-file
       summaryFileName = 'aROI_'+contrast+'.csv'
   
       #store output into a cvs-file
       f = open(path2aROIOut+'/'+summaryFileName,'wb')
       import csv
       outputFile = csv.writer(f)
       for line in output:
           outputFile.writerow(line)
       f.close()


.. hint::

   The code for this anatomical ROI pipeline can be found here: `aROIpipeline.py <http://github.com/miykael/nipype-beginner-s-guide/blob/master/aROIpipeline.py>`_


Folder structure after ``aROIflow``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After we've run the **anatomical ROI pipeline** our folder structure should look like this:

.. image:: aROI.png
   :width: 810

Additionally to the ``level2_output`` folder in ``~SOMEPATH/experiment/results/`` we now have the new folders:

* **workingdir_aROI** folder that contains all the data that gets created from the ``aROIflow`` pipeline. As with all working directories, it  is **highly recommended** to delete this folder as soon as possible.
* **aROI_output** folder which is the datasink of the **anatomical ROI pipeline**. It contains:

   - **segstatorig** folder with the ``summary.stats`` file from the original segmentation for each contrast and subject
   - **segstat2009** folder with the ``summary.stats`` file from the 2009 segmentation for each contrast and subject

.. note::

   If you run the additional python code that is at the end of the script, the summarization files that get created will be stored in ``~SOMEPATH/experiment/results/aROI_output``.


Functional ROI Pipeline
=======================

Before we start with the creation of our **functional ROI pipeline**, let's have a closer look at step 1a, 1b and 2 from the introduction part above. To do those steps we use ``fslmaths`` from the FSL interface which we will be implementing in Nipype with the ``fsl.ImageMaths()`` interface. Sometimes it is helpfull or necessary to know what the final command will be before creating the nodes.

**Step 1a** will be implemented by a node called ``cubemask``. This node will create the following FSL command:

.. code-block:: sh

   fslmaths ~SOMEPATH/experiment/results/level1_output/normcons/subject2/
   con_0001_ants.nii -mul 0 -add 1 -roi 159 40 109 40 87 40 0 1 ~SOMEPATH/experiment/
   results/workingdir_fROI/fROIflow/cubemask/con_0001_ants_maths.nii.gz -odt float

**Step 1b** will be implemented by a node called ``spheremask``. This node will create the following FSL command:

.. code-block:: sh

   fslmaths ~SOMEPATH/experiment/results/workingdir_fROI/fROIflow/cubemask/
   con_0001_ants_maths.nii.gz -kernel sphere 20 -fmean -thr 0.5 -bin ~SOMEPATH/experiment/
   results/workingdir_fROI/fROIflow/spheremask/con_0001_ants_maths_maths.nii.gz -odt float

**Step 2** will be implemented by a node called ``tmapmask``. This node will create the following FSL command:

.. code-block:: sh

   fslmaths ~SOMEPATH/experiment/results/workingdir_fROI/fROIflow/spheremask/
   con_0001_ants_maths_maths.nii.gz -mul ~SOMEPATH/experiment/results/level2_output/
   l2vol_contrasts_thresh/_con_4/spmT_0001_thr.hdr -bin ~SOMEPATH/experiment/
   results/workingdir_fROI/fROIflow/_contrast_id_4_subject_id_subject2/tmapmask/
   con_0001_ants_maths_maths_maths.nii.gz -odt float


.. note::

   If you are interested in what commandline an interface like ``fsl.ImageMaths()`` actually will be executing use the command ``nodename.cmdline`` (e.g. ``cubemask.cmdline`` if ``cubemask = fsl.ImageMaths()``). But for this to work ``cubemask`` mustn't be defined as a node like ``pe.Node(interface=fsl.ImageMaths(),name="cubemask")``.

   More informations about the different arguments of ``fslmaths`` can be found `here <http://ric.uthscsa.edu/personalpages/lancaster/SPM_Class/Lecture_18/fslmaths.doc>`_. To be on the safe side, I additionally copied it's content into `fslmaths.txt <http://github.com/miykael/nipype-beginner-s-guide/blob/master/fslmaths.txt>`_.

   **Important:** This document wasn't created by me, I just stumbled upon it. But it is the best and most detailed one I've found.


How those FSL commands can be achieved by using Nipype can be found in the code later on. Let's now start building our **functional ROI pipeline**.


Import modules
~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   import os                                    # system functions
   import nipype.interfaces.freesurfer as fs    # freesurfer
   import nipype.interfaces.io as nio           # i/o routines
   import nipype.interfaces.utility as util     # utility
   import nipype.pipeline.engine as pe          # pypeline engine
   import nipype.interfaces.fsl as fsl          # fsl module


Define experiment specific parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   #to better access the parent folder of the experiment
   experiment_dir = '~SOMEPATH/experiment'

   #dirnames for functional ROI and of level1 datasink
   fROIOutput = 'fROI_output'      #name of fROI datasink
   l1contrastDir = 'level1_output' #name of first level datasink

   #list of subjectnames
   subjects = ['subject1','subject2','subject3']

   #list of contrastnumbers the pipeline should consider
   contrasts = [1,2,3,4,5]


Define fROI specific parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   #define the coordination of the point of interest
   centerOfROI = [179,129,107]
   
   #define the radius of the sphere of interest
   radius = 20

   #calculates the beginning corner of the cubic ROI
   corner = [centerOfROI[0]-radius,
             centerOfROI[1]-radius,
             centerOfROI[2]-radius]


Definition of Nodes
~~~~~~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   #Node: IdentityInterface - to iterate over subjects and contrasts
   inputnode = pe.Node(interface=util.IdentityInterface(fields=['subject_id',
                                                                'contrast_id']),
                       name='inputnode')
   inputnode.iterables = [('subject_id', subjects),
                          ('contrast_id', contrasts)]

   #Node: DataGrabber - To grab the input data
   datasource = pe.Node(interface=nio.DataGrabber(infields=['subject_id','contrast_id'],
                                                  outfields=['contrast']),
                        name = 'datasource')
   datasource.inputs.base_directory = experiment_dir + '/results/' + l1contrastDir
   datasource.inputs.template = 'norm%s/%s/%s_%04d_ants.nii'
   info = dict(contrast = [['cons','subject_id','con','contrast_id']])
   datasource.inputs.template_args = info
   
   #Node: ImageMaths - to create the cubic ROI with value 1
   cubemask = pe.Node(interface=fsl.ImageMaths(),name="cubemask")
   cubeValues = (corner[0],radius*2,corner[1],radius*2,corner[2],radius*2)
   cubemask.inputs.op_string = '-mul 0 -add 1 -roi %d %d %d %d %d %d 0 1'%cubeValues
   cubemask.inputs.out_data_type = 'float'
   pathValues = (subjects[0],contrasts[0])
   cubemask.inputs.in_file='~SOMEPATH/experiment/normcons/%s/con_%04d_ants.nii'%pathValues
   
   #Node: ImageMaths - to transform the cubic ROI to a spherical ROI
   spheremask = pe.Node(interface=fsl.ImageMaths(),name="spheremask")
   spheremask.inputs.op_string = '-kernel sphere %d -fmean -thr 0.5 -bin'%radius
   spheremask.inputs.out_data_type = 'float'
   
   #Node: ImageMaths - to mask the spherical ROI with a subject specific T-map
   tmapmask = pe.Node(interface=fsl.ImageMaths(),name="tmapmask")
   tmapmask.inputs.out_data_type = 'float'

   #function to add the thresholded group T-map to op_string
   def groupTMapPath(contrast_id):
       experiment_dir = '~SOMEPATH/experiment'
       path2con = 'results/level2_output/l2vol_contrasts_thresh'
       op_string = '-mul %s/%s/_con_%d/spmT_0001_thr.hdr -bin'
       return op_string%(experiment_dir,path2con,contrast_id)

   #Node: SegStats - to extract the statistic from a given segmentation
   segstat = pe.Node(interface=fs.SegStats(),name='segstat')
   
   #Node: Datasink - Create a datasink node to store important outputs
   datasink = pe.Node(interface=nio.DataSink(), name="datasink")
   datasink.inputs.base_directory = experiment_dir + '/results'
   datasink.inputs.container = fROIOutput


Definition of functional ROI workflow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   #Initiation of the fROI extraction workflow
   fROIflow = pe.Workflow(name='fROIflow')
   fROIflow.base_dir = experiment_dir + '/results/workingdir_fROI'
   
   #Connect up all components
   fROIflow.connect([(cubemask, spheremask,[('out_file','in_file')]),
                     (spheremask, tmapmask,[('out_file','in_file')]),
                     (inputnode, tmapmask,[(('contrast_id',groupTMapPath),
                                            'op_string')
                                           ]),
                     (inputnode, datasource,[('subject_id','subject_id'),
                                             ('contrast_id','contrast_id')
                                             ]),
                     (tmapmask, segstat,[('out_file','segmentation_file')]),
                     (datasource, segstat,[('contrast','in_file')]),
                     (segstat, datasink,[('summary_file','@statistic')]),
                     ])
   

Run the pipeline and generate the graph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: py
   :linenos:

   fROIflow.write_graph(graph2use='flat')
   fROIflow.run(plugin='MultiProc', plugin_args={'n_procs' : 4})


Visualization of the functional ROI pipeline
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This graph of the ``hierarchical`` version shows the ``fROIflow``:

.. image:: fROI_hierarchical.png
   :width: 640 px

This detailed graph of the ``flat`` version shows the ``fROIflow``:

.. image:: fROI_detailed.png
   :width: 810 px
   

Summarizing the output in a cvs-file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This part is optional and shows only one of many ways how you can summarize the output of ``fROIflow`` into a common cvs-file. In essence it does the following steps:

* grab contrast and subject specific summary.stats file
* extract values from this file and store it into a list
* add the list of each subject into a bigger list
* store this big list into a csv-file


.. code-block:: py
   :linenos:

   #creates the big list and its header
   output = []
   output.append(['coordinations:',centerOfROI,'radius:',radius])

   #iterate over contrasts
   for contrast in contrasts:

       #creates header for each contrast
       contrast = str(contrast)
       output.append(['contrast:',contrast])
   
       #iterate over subjects
       for subject in subjects:

           #specify path to fROI datasink for each variation of segmentation
           path2fROIOut = experiment_dir+'/results/'+fROIOutput + '/'
           path2Sumfile = '_contrast_id_'+contrast+'_subject_id_'+subject
           statFile = path2fROIOut + path2Sumfile + '/summary.stats'
   
           #extract the data from the output summary files
           dataFile = open(statFile, 'r')
           data = dataFile.readlines()
           dataFile.close()

           #add value of functional region   
           output.append([subject,data[-1].split()[5]])
   
       #add an empty line at the end of a contrast summary
       output.append([])
   
   #store output into a cvs-file
   f = open(path2fROIOut+'/fROI_spherical'+str(centerOfROI)+'_%s_result.csv'%radius,'wb')
   import csv
   outputFile = csv.writer(f)
   for line in output:
       outputFile.writerow(line)
   f.close()


.. hint::

   The code for this functional ROI pipeline can be found here: `fROIpipeline.py <http://github.com/miykael/nipype-beginner-s-guide/blob/master/fROIpipeline.py>`_


Folder structure after ``fROIflow``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After we've run the **functional ROI pipeline** our folder structure should look like this:

.. image:: fROI.png
   :width: 810

Additionally to the ``level2_output`` folder in ``~SOMEPATH/experiment/results/`` we now have the new folders:

* **workingdir_fROI** folder that contains all the data that gets created from the ``fROIflow`` pipeline. As with all working directories, it  is **highly recommended** to delete this folder as soon as possible.
* **fROI_output** folder which is the datasink of the **functional ROI pipeline**. In this folder you'll find the ``summary.stats`` file for the defined functional region for each contrast and subject

.. note::

   If you run the additional python code that is at the end of the script, the summarization files that get created will be stored in ``~SOMEPATH/experiment/results/fROI_output``.
